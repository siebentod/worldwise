const apiKey =
  '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';

let TAGS;

let TITLE = '"Означаемое" и "означающее" у де Соссюра';

let TEXT = `Фердинанд де Соссюр, швейцарский лингвист и один из основателей структурализма, предложил концептуальную основу, без которой современная лингвистика была бы немыслима. Его ключевое разделение на "означаемое" и "означающее" стало краеугольным камнем в изучении языка как системы знаков. Это разделение вытекает из его идеи о языке как структуре, где каждый элемент получает значение только через отношения с другими элементами.

В центре внимания де Соссюра находится понятие **"знака" как единства формы и содержания**. Знак для него — это не вещь, а связь. Например, слово "дерево" в русском языке не связано непосредственно с объектом природы, а выступает посредником между звуками, из которых состоит слово, и концепцией дерева, существующей в сознании. Именно это и обуславливает необходимость различения двух сторон знака.

"Означающее" представляет собой **материальную форму знака**. Это могут быть звуки речи, буквы на бумаге или жесты в языке жестов. Означающее всегда физически ощутимо, оно выступает как оболочка знака. Важным аспектом является то, что означающее само по себе не обладает значением: звукосочетание "дерево" вне языковой системы ничего не говорит о самом дереве.

"Означаемое" — это **ментальная концепция или идея**, которую вызывает означающее. Оно не является самим объектом реального мира, а лишь его представлением в сознании. Когда мы слышим или читаем "дерево", перед нами возникает образ растения с корнями, стволом и ветвями. Однако в других языках то же понятие может быть связано с совершенно иными звучаниями.

Знак, по Соссюру, возникает только в результате связи означающего и означаемого. Эта связь **не является естественной, а носит условный характер**. Нет причин, почему именно звукосочетание "дерево" ассоциируется с конкретным представлением, кроме культурного соглашения внутри языковой общности. Это условность делает возможным существование множества языков, каждый из которых строит свои собственные системы связи между звуками и смыслами.

Ключевое значение для понимания этой концепции имеет **принцип различия**. Означающее получает свое значение не благодаря своей внутренней сущности, а через противопоставление другим означающим. Так, слово "дерево" обретает смысл только потому, что отличается от "дрова", "лес" или "стол". В этом состоит структурализм де Соссюра: язык — это сеть различий, а не собрание самостоятельных сущностей.

Наконец, важно понимать, что связь между означаемым и означающим **является динамической**. Она может изменяться со временем, приводя к смещению значений. История языков изобилует примерами того, как звучание и смысл слов трансформировались, порой утрачивая первоначальную связь. Это делает язык не только системой, но и живым организмом, чье изучение остается актуальным и сегодня.`;

const prompt = `Текст статьи: ${TEXT};
  
  Напиши 7 тегов для статьи в разделе "Философия" под названием ${TITLE}.
    
  1. Главный источник генерации тегов – НАЗВАНИЕ, содержание статьи второстепенно.
  2. Теги скорее должны касаться затрагиваемого автора и раздела философии, а не "ключевых тем". Неправильно: "социальная ответственность", "человеческая природа", правильно: "Кант", "Ницше", "Этика Добродетели", "Новое Время".
  3. Чем короче тег, тем лучше. Неправильно: "Ведический Санскрит", правильно: "Веды", "Санскрит". Из имени философа оставляй только фамилию, неправильно: "Артур Шопенгауэр", правильно: "Шопенгауэр". Мне нужно, чтобы под тег подпадало много разных статей!
  4. Теги только с большой буквы.
  
  Формат ответа: ["Тег1", "Тег2", "Тег3", "Тег4", "Тег5"]`;

(async function GPTWork() {
  await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model: 'gpt-4o-mini',
      store: true,
      messages: [
        {
          role: 'user',
          content: prompt,
        },
      ],
    }),
  })
    .then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then((data) => {
      TAGS = data.choices[0].message.content;
      console.log(data);
      console.log('Text generated successfully. Model:', data.model);
    })
    .catch((error) => {
      console.error('Error:', error);
    });

  const fileContent = `${TAGS}`;

  // Создаем файл для скачивания
  const blob = new Blob([fileContent], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `TAGS.md`;
  a.click();
  URL.revokeObjectURL(url);
})();
